"""
알고리즘에서 시간 복잡도는 주어진 문제를 해결하기 위한 연산 횟수를 말합니다.
일반적으로 python programe에서는 2000만번 ~ 1억번의 연산을 1초의 수행시간으로 예측할 수 있습니다.


시간 복잡도 유형
- 빅 오메가 : 최선일 떄(best case)의 연산 횟수를 나타낸 표기법
- 빅 세타 : 보통일 때(average case)의 연산 횟수를 나타낸 표기법
- 빅 오 : 최악일 때(wosrt case)의 연산 횟수를 나타낸 표기법
"""

# 시간 복잡도 예제 코드
import random
findNumber = random.randrange(1, 101)

for i in range(1, 101):
    if i == findNumber:
        print(i)
        break

"""
위 코드의 빅-오메가의 표기법의 시간 복잡도는 1번, 빅-세타 표기법은 시간 복자도는 N/2번, 빅-오 표기법은 N번입니다.

그럼 코딩 테스트에서는 빅-오 표기법을 기준으로 수행 시간을 계산하는 것이 좋습니다.

실제 테스트에서는 1개의 테스트 케이스로 합격, 불합격을 결정하지 않습니다.
"""

"""
버블 정렬과 병합 정렬의 시간 복잡도를 각각 O(n2) (O(logn))

연산 횟수 = 알고리즘 시간 복잡도 n값에 데이터의 최대 크기를 대입하여 도출
"""

# 수 정렬하기 예제 코드

## 연산 횟수 = N
N = 100000
cnt = 1

for i in range(N):
    print("연산 횟수 " + str(cnt))
    cnt += 1

## 연산 횟수 = 3N
N = 100000
cnt = 1

for i in range(N):
    print("연산 횟수 " + str(cnt))
    cnt += 1

for i in range(N):
    print("연산 횟수 " + str(cnt))
    cnt += 1

for i in range(N):
    print("연산 횟수 " + str(cnt))
    cnt += 1

"""
두 예제 코드의 연산 횟수는 3배의 차이가 납니다.
언뜻 생각하면 큰 차이인 것 같지만 코딩 테스트에소는 일반적으로 상수는 무시하므로 두 코드 모두 O(n)
"""

## 연산 횟수 = N2
N = 100000
cnt = 1

for i in range(N):
    for j in range(N):
        print("연산 횟수 " + str(cnt))
        cnt += 1

"""
시간 복잡도는 가장 많이 중첩된 반복문을 기준으로 도출하므로 이 코드에서는 이중 for문이 전체 코드의 시간 복잡도 기준이 됩니다.
만일 일반 for문이 10개가 더 있다 하더라도 도출 원리의 기준에 따라 시간 복잡도는 N2으로 유지됩니다.
"""