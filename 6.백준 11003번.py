"""
일정 범위 안에서 최솟값을 구하는 문제이므로 슬라이딩 윈도우와 정렬을 사용하면 될 것 같습니다.
윈도우의 크기는 문제에서 최솟값을 구하는 범위가 i-L+1부터 i까지이므로 L로 생각하면 됩니다.
최솟값을 찾기 위한 정렬은?
일반적으로 정렬은 O(nlogn)의 시간 복잡도를 가지는데 N과 L의 최대 범위가 5,000,000인 이 문제에서는 정렬을 사용할 수는 없다.

다시 말해 O(n)의 시간복잡도로 해결해야한다. 하시만 슬라이딩 윈도우를 deque(덱)으로 구현하여 정렬 효과를 볼 수 있다.

"""

"""
손으로 풀기

1. 덱에서는 인덱스와 숫자를 같이 저장

1-1. 최소값 가능성 없는 데이터 삭제
1-2. window 크기 밖 데이터 삭제

2. (1-1) 기존 덱에 있는 값이 새로 들어오는 값보다 크면 그 이전 값은 삭제 (문제가 최솟값을 찾는거니깐 상관X)
    1,1 | 2,5 덱에 새로운 3,2가 들어옴 우리가 확인해야하는것은 최솟값을 구하는 문제이므로  3,2보다 큰 2,5는 필요 없다고 판단할 수 있음
    그러므로 2,5는 삭제
    1,1 | 3,2

3. (1-2) 인덱스 범위가 슬라이딩 윈도우를 벗어난 예 / L 사이즈를 넘어가는 것은 필요 없다.
    1,1 | 3,2 덱에 새로운 4,3이 들어옴 여기서는 L 즉 윈도우 사이즈가 3이라고 지정함
    그러므로 이미 인덱스 2, 3, 4를 탐색 (앞에서부터 비교) 을 했으므로 1,1은 윈도우 범위를 벗어남  1,1 삭제
    3,2 | 4,3
"""

"""
슈도코드 작성

N(데이터 개수) L(윈도우 사이즈)
mydeque(데이터를 담는 덱 자료구조)
now(주어진 숫자 데이터를 가지는 리스트)

for N만큼 반복:
    덱의 마지막 위치에서부터 현재 값보다 큰 값은 덱에서 제거
    덱의 마지막 위치에 현재 값 저장
    덱의 1번째 위치에서부터 L의 범위를 벗어난 값(now index-L <= index)을 덱에서 제거
    덱의 1번째 데이터 출력
"""

import sys
from collections import deque
input = sys.stdin.readline

N, L = map(int, input().split())
mydeque = deque()
now = list(map(int, input().split()))

for i in range(N):
    while mydeque and mydeque[-1][0] > now[i]:
        mydeque.pop()
    mydeque.append((now[i], i))

    if mydeque[0][1] <= i - L:
        mydeque.popleft()

    print(mydeque[0][0], end=' ')
